字符串不是基本类型，而是引用类型
浮点型只是一个近似值，并非精确的值
数据范围与字节数不一定相关，例如float数据的范围比long更加广泛，但float是4字节，long是8字节
浮点数当中默认类型是double，如果一定要使用float类型，需要加上一个后缀F
如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L，推荐使用大写字母后缀


自增自减运算符
1、如果单独使用的时候，前++和后++没有任何区别
2、如果混合使用的时候，有重大区别
	A、如果是【前++】，那么变量【立刻马上+1】，然后拿着结果进行使用	【先加后用】
	B、如果是【后++】，那么首先使用变量本身的数值，【然后再让变量+1】  【先用后加】

与“&&”，或“||”，具有短路效果，如果根据左边已经可以判断最终结果，那么代码右边的代码不再执行，从而节省一定的性能

三元运算符格式
数据类型 变量名称 = 条件判断 ？ 表达式A ：表达式B；

switch语句后面的小括号只能是下列数据类型：
	基本数据类型：byte/short/char/int
	引用数据类型：String字符串、enum枚举

所有的源代码都要写到src文件夹下

方法重载与下列因素相关：
1、参数的个数
2、参数类型不同
3、参数的多类型顺序不同

方法的重载与下列因素无关
1、与参数的名称无关
2、与方法的返回值类型无关

数组的特点：
1、数组是一种引用的数据类型
2、数组当中的多个数据，类型必须统一
3、数组的长度在程序运行期间不可改变

两种常见的数组初始化方式：
1、动态初始化（指定长度）
2、静态初始化（指定内容）

动态初始化数组的格式：
方法一：数据类型[] 数组名称 = new 数据类型[数组长度];
方法二：数据类型[] 数组名称；
              数组名称 = new 数据类型[数组长度];

静态初始化数组的格式：
方法一：数据类型[] 数组名称 = new 数据类型[] { 元素1， 元素2, .....};
省略格式：数据类型[] 数组名称 = { 元素1， 元素2, .....};
方法二：数据类型[] 数组名称；
              数组名称 = new 数据类型[] { 元素1， 元素2, .....};
注意：如果静态初始化方法一旦使用了省略格式，就不能拆分成两个步骤了

直接打印数组名称，得到的是数组对应的：内存地址哈希值

使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值，规则如下：
如果是整数类型:byte/short/int/long,那么默认是0
如果是浮点类型:float/double,那么默认是0.0
如果是字符类型:那么默认是'\u0000'
如果是布尔类型:那么默认是false
如果是引用类型:那么默认为null

注意事项：静态初始化其实也有默认值的过程，只不过系统马上将默认值替换成为了大括号当中的具体数值

Java的内存需要划分成5个部分：
1、栈（Stack）：存放的都是方法中展示的局部变量。方法的运行一定要在栈当中运行
	局部变量：方法的参数，或者是方法{}内部的变量
	作用域：一旦超过作用域，立刻从栈内存中消失
2、堆（Heap）：凡是new出来的东西，都在堆当中
	堆内存里面的东西都有一个地址值：16进制
	堆内存里面的数据都有默认值，规则与上面相同
3、方法（Method Area）：存储.class相关信息，包含方法的信息
4、本地方法栈（Native Method Stack）：与操作系统相关
5、寄存器（pc Register）：与CPU相关


所有的引用类型都可以赋值为一个null，表示什么都没有

数组可以作为方法的参数
当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值

当数组作为方法的返回值，返回的其实也是数组的地址值


1、成员变量是直接定义在类当中的，在方法外边
2、成员方法不要写static关键字

导包：import 包名称.类名称
对于和当前类属于同一个包的情况，可以省略导包语句不写
只有java.lang包下的内容不需要导包，其他的包都需要import语句

创建对象
类名称 对象名 = new 类名称();

当一个对象作为参数传递到方法当中时，实际上传递进去的是对象的地址值

当使用一个对象类型作为方法的返回值时，返回的其实就是对象的地址值

局部变量和成员变量
1、定义的位置不一样
	局部变量：在方法的内部
	成员变量：在方法的外部，直接写在类当中
2、作用范围不一样
	局部变量：只有方法当中才可以使用，出了方法就不能再用
	成员变量：整个类全部通用
3、默认值不一样
	局部变量：没有默认值，如果要想使用，必须手动进行赋值
	成员变量：如果没有赋值，会有默认值，规则和数组一样
4、内存的位置不一样
	局部变量：位于栈内存
	成员变量：位于堆内存
5、生命周期不一样
	局部变量：随着方法进栈而诞生，随着方法出栈而消失
	成员变量：随着对象创建而诞生，随着对象垃圾回收而消失

一旦使用了private进行修饰，那么本类当中仍然可以随意访问
但是，超出本类范围之外就不能再直接访问了

间接访问private成员变量，就是定义一对Getter/Setter方法
如果返回值但会的是布尔类型，那么就不能就getXxxx，而要改成isXxxx，而setXxx规则不变

当方法的局部变量和类的成员变量重名的时候，根据"就近原则"，优先使用局部变量

"通过谁调用的方法，谁就是this"

构造方法注意事项：
1、构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样
2、构造方法不要写返回值类型，连void都不写
3、构造方法不能return一个具体的返回值
4、如果没有编写任何构造方法，那么编译器j将会默认赠送一个构造方法，没有参数，方法体什么事情也不做
5、一旦编写了至少一个构造方法，那么编译器将不再赠送
6、构造方法也是可以进行重载的

一个标准的类通常要拥有下面四个组成部分
1、所有的成员变量都要使用private关键字修饰
2、为每一个成员变量写一对Getter/Setter方法
3、编写一个无参的构造方法
4、编写一个全参的构造方法

这样的标准类也叫做Java Bean

创建Scanner类中，添加的System.in代表从键盘输入

键盘输入的东西全都是字符串，nextInt等方法就是将对应字符串换成对应的类型

Random生成一个随机数字，以获取一个随机整数为例，可以使用nextInt来获取，如果调用方法的时候不传参，那么返回的整数值就是对应类型的的范围内的随机一个（int类型范围内所有的值都有可能，可正可负）
如果对应方法传入对应的值的话，获取的范围是一个左闭右开的区间

数组的长度不可以改变。
但是ArrayList集合的长度是可以随意变化的

对于ArrayList来说，有一个尖括号<E>代表泛型
泛型：也就是装在集合当中的所有元素，全都是统一的什么类型
注意：泛型只能是引用类型，不能是基本类型

创建一个ArrayList格式
ArrayList<引用类型> 集合名称 = new ArrayList<引用类型>();
备注：从jdk1.7+开始，右侧的尖括号内可以不写内容，但是<>本身还是要写的

注意事项：
对于ArrayList集合来说，直接打印得到的不是地址值，而是内容
如果内容为空，得到的是一个空的中括号

ArrayList的add方法在讲元素加入集合的同时，还是返回一个布尔值，这个布尔值表示是否插入成功
对于ArrayList来说，add添加动作一定是成功的，所以返回值可用可不用
但是对于其它集合来说，add添加动作不一定成功

通过get方法获取对应索引值的内容

remove方法可以删除对应索引值的内容，并返回删除的内容

泛型只能是引用类型，不能是基本类型
如果希望向ArrayList中存储基本类型，必须使用基本类型对应的包装类

基本类型		包装类（引用类型，包装类都位于java.lang包下）
byte		Byte
short		Short
int		Integer
long		Long
float		Float
double		Double
char		Character
boolean		Boolean

从jdk1.5+开始，支持自动装箱、自动拆箱
自动装箱：基本类型 --> 包装类型
自动拆箱：包装类型 --> 基本类型

字符串的特点
1、字符串的内容永不可变
2、正是因为字符串不可改变， 所以字符串是可以共享使用的
3、字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组


创建字符串的常见3+1种
三种构造方法：
public String(): 创建一个空白字符串，不含有任何内容
public String(char[] array):根据字符数组的内容，来创建对应的字符串
public String(byte[] array):根据字节数组的内容，来创建对应的字符串
一种直接创建：
String str = "xxxxx"

注意：对于字符串来说，就是字符串对象

字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中
		（换言之：只有双引号直接写上的字符串才在池中）
		new的字符串不在字符串常量池中

对于基本类型来说， ==是进行数值的比较
对于引用类型来说， ==是进行地址值的比较


没讲的内容
多维数组
for each方法

























































