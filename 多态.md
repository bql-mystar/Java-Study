- extends继承和implements实现，是多态性的前提

- 代码中体现多态性：其实就是一句话：父类引用指向子类对象
  格式：
  `父类名称 对象名 = new 子类名称();`
  或者：
  `接口名称 对象名 = new 实现类名称();`

- 多态访问成员变量的两种方式：

  1. 直接通过对象名访问成员变量：看等号左边是谁，优先用谁，没有则向上找
  2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找

- 在多态的代码当中，成员方法的访问规则是：
  看new的是谁，就优先用谁，没有则向上找

  ​		口诀：编译看左边，运行看右边

- 成员变量：编译看左边，运行还看左边
  成员方法：编译看左边，运行看右边

- 对象的向上转型，其实就是多态写法：
  格式：`父类名称 对象名 = new 子类名称();`

  注意事项：向上转型一定是安全的，从小范围转向了大范围
  类似于：自动类型转换，从小范围转向大范围

- 向上转型一定是安全的，没有问题的，正确的，但是也有一个弊端：
  对象一旦向上转型为父类，那么就无法调用子类原本特有的方法
  解决方法：用对象的向下转型还原

- 对象的向上转换，其实就是一个还原的动作
  格式：`子类名称 对象名 = (子类名称) 父类对象;`
  含义：将父类对象换成成本来的子类对象
  注意事项（以猫狗举例）：
      a. 必须保证本来对象创建的时候，就是猫，才能向下转型成为猫

  ​	b. 如果创建的时候本来不是猫，现在非要向下转型成为猫，就会报错，编译不会报错，但是运行会出现异常：`java.lang.ClassCastException，类转换异常`

- instanceof可以判断一个父类引用对象本来是什么子类
  格式： `对象 instanceof 类名称`
  这将会得到一个boolean值结果，也就是判断前面的对象能不能当作后面类型的实例